<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 1.0.0" />
    <title>Guide</title>
    
    
    <meta name="description" content="docs" />
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/creative-scala.css" /><link rel="stylesheet" type="text/css" href="xterm.css" />
    <script src="js/toc.js"></script><script src="js/solution.js"></script><script src="main.js"></script><script src="xterm.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar">
      <details>
        <summary>Terminus</summary>
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="quick-start.html">Quick Start</a></li>
          <li class="level1 active nav-leaf"><a href="#">Guide</a></li>
          <li class="level1 nav-leaf"><a href="examples.html">Examples</a></li>
          <li class="level1 nav-leaf"><a href="design.html">Design</a></li>
          <li class="level1 nav-leaf"><a href="jvm.html">JVM Backend</a></li>
          <li class="level1 nav-leaf"><a href="js.html">Javascript Backend</a></li>
          <li class="level1 nav-leaf"><a href="native.html">Native Backend</a></li>
        </ul>
      </details>
    </nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="index.html">Terminus</a></li>
          <li class="level1 nav-leaf"><a href="quick-start.html">Quick Start</a></li>
          <li class="level1 active nav-leaf"><a href="#">Guide</a></li>
          <li class="level1 nav-leaf"><a href="examples.html">Examples</a></li>
          <li class="level1 nav-leaf"><a href="design.html">Design</a></li>
          <li class="level1 nav-leaf"><a href="jvm.html">JVM Backend</a></li>
          <li class="level1 nav-leaf"><a href="js.html">Javascript Backend</a></li>
          <li class="level1 nav-leaf"><a href="native.html">Native Backend</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="guide" class="title">Guide</h1>
            
            <h2 id="imports" class="section">Imports</h2>
            <p>The standard import is just</p>
            <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">terminus</span><span>.*</span></code></pre>
            <p>This will import</p>
            <ol class="arabic">
              <li>the <code>Terminal</code> object, which contains all the methods you&#39;ll use;</li>
              <li>the <code>Terminal</code> type, which represents a backend-specific implementation; and</li>
              <li>the <code>Program</code> type, described immediately below.</li>
            </ol>
            
            <h2 id="programs" class="section">Programs</h2>
            <p>In Terminus you construct a program that says what you want to do with the terminal, and then <code>run</code> that program when it is fully constructed. This is similar to using the <code>IO</code> monad, where you construct the monad stating what you want to do and then call one of the <code>unsafe</code> methods to carry out those actions.</p>
            <p>In Terminus program is basically a function that accepts some state representing the terminal and returns a value of type <code>A</code>. More concretely it is</p>
            <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Program</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">Terminal</span><span> ?=&gt; </span><span class="type-name">A</span></code></pre>
            <p>where <code>Terminal</code> is a backend specific implementation that handles interfacing with the terminal on that platform.</p>
            
            <h2 id="working-with-context-functions" class="section">Working with Context Functions</h2>
            <p>Context functions are new to Scala 3, so many developers may not be familiar with how they work. There are three rules for working with them, described below.</p>
            <p>The first rule is that if the compiler can tell that a context function is expected it will automatically create one. We can do this with a <code>Program</code> type annotation. Here are some examples</p>
            <pre><code class="nohighlight"><span class="comment">// Most of the methods on Terminal return programs
</span><span class="keyword">val</span><span> </span><span class="identifier">aTerminalOperation</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some text&quot;</span><span>)

</span><span class="comment">// Any expression can be a Program with a type annotation
</span><span class="keyword">val</span><span> </span><span class="identifier">aProgram</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span></code></pre>
            <p>The second rule is that context functions will be automatically applied if there is a <code>given</code> value of the appropriate type in scope. This is what allows us to write effectful code in so-called <em>direct-style</em>, which just means writing normal code without monads or other complications. Here&#39;s an example that mixes effectful code, using the terminal, with some normal code. Notice that the entire result is a <code>Program</code>. This type annotation means the compiler constructs a context function around the entire block.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">writeSomeStuff</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
  </span><span class="comment">// We can mix normal code in
</span><span>  </span><span class="keyword">val</span><span> </span><span class="identifier">result</span><span> = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;More output&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
  </span><span class="identifier">result</span><span>
}</span></code></pre>
            <p>We can do the same thing with a method, by specifying the return type is a <code>Program</code>. Here&#39;s an example.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">doSomeStuff</span><span>(): </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">result</span><span> = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;More output&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
  </span><span class="identifier">result</span><span>
}</span></code></pre>
            <p>The final rule is if we don&#39;t tell the compiler we&#39;re expecting a context function, we may get an error when the compiler attempts to apply a context function to a given value that does not exist.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
</span><span class="comment">// error: 
// No given instance of type terminus.effect.Writer was found for parameter of (terminus.effect.Writer) ?=&gt; Unit</span></code></pre>
            <p>We can solve this by either adding a context function type annotation</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ok</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)</span></code></pre>
            <p>or by providing a <code>given</code> value of the required type, which is what <code>Terminal.run</code> does.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span>(</span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>))</span></code></pre>
            
            <h2 id="building-terminal-programs" class="section">Building Terminal Programs</h2>
            <p>In Terminus you build programs by calling methods on the <code>Terminal</code> object. This section describes the most important methods. See the API <a class="api" href="https://javadoc.io/doc/org.creativescala/terminus-docs_3/latest/terminus/index.html">index</a> for more.</p>
            
            <h3 id="writing-to-the-terminal" class="section">Writing to the Terminal</h3>
            <p>Call the <code>write</code> method to send a <code>String</code> or <code>Char</code> to the terminal. On most terminals you&#39;ll need to call <code>flush</code> before your output actually appears.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span> {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;“Either write things worth reading or do things worth the writing.”</span><span class="escape-sequence">\r\n</span><span class="string-literal">  -Benjamin Franklin&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
}</span></code></pre>
            <p>This produces the output shown below. Note that the terminal does not follow the Unix convention and interpret a newline (<code>\n</code>) as both a carriage return (<code>\r</code>) and a newline. We must specify both if we want to move down a line and return to the leftmost column.</p>
            <div class="doodle" id="write"></div>
            <script>Write.go("write")</script>
            
            <h3 id="reading-from-the-terminal" class="section">Reading from the Terminal</h3>
            <p>Call <code>read</code> to wait for a character from the terminal. This returns character codes directly as sent by the terminal, which uses escape codes to encode various keys. For example, the up arrow is represented as the sequence of characters <code>ESC</code>, <code>[</code>, and <code>A</code>. You&#39;ll have to, for now, parse these yourself.</p>
            
            <h3 id="formatting-output" class="section">Formatting Output</h3>
            <p>Terminus provides many methods to control the formatting of text in the terminal. You can set the foreground or background, make text bold, make text blink, and a lot more. See the <a class="api" href="https://javadoc.io/doc/org.creativescala/terminus-docs_3/latest/terminus/effect/Display.html">Display</a> and <a class="api" href="https://javadoc.io/doc/org.creativescala/terminus-docs_3/latest/terminus/effect/Color.html">Color</a> API documentation to see everything that is available.</p>
            <p>These methods all take a <code>Program</code> as a parameter. The effect is applied to any output from that <code>Program</code> program, but it not persist outside the scope of the method. These methods can be arbitrarily nested, and will work correctly. For example, we can nest green text inside yellow text and get the correct mix of yellow and green.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span> {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">foreground</span><span>.</span><span class="identifier">yellow</span><span> {
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Yellow &quot;</span><span>)
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">foreground</span><span>.</span><span class="identifier">green</span><span>(</span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Green &quot;</span><span>))
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Yellow &quot;</span><span>)
  }
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Unstyled&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
}</span></code></pre>
            <div class="doodle" id="nested-format"></div>
            <script>NestedFormat.go("nested-format")</script>
            <p>This example shows some more of the formatting options available.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span> {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">display</span><span>.</span><span class="identifier">bold</span><span>(
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">display</span><span>.</span><span class="identifier">strikethrough</span><span>(
      </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Bold and strikethrough</span><span class="escape-sequence">\r\n</span><span class="string-literal">&quot;</span><span>)
    )
  )
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">foreground</span><span>.</span><span class="identifier">white</span><span>(
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">background</span><span>.</span><span class="identifier">red</span><span>(
      </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Foreground and background color</span><span class="escape-sequence">\r\n</span><span class="string-literal">&quot;</span><span>)
    )
  )
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">display</span><span>.</span><span class="identifier">invert</span><span>(
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">display</span><span>.</span><span class="identifier">underline</span><span>.</span><span class="identifier">curly</span><span>(
      </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Inverted with curly underline&quot;</span><span>)
    )
  )
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
}</span></code></pre>
            <div class="doodle" id="format"></div>
            <script>Format.go("format")</script>
            
            <h3 id="running-programs" class="section">Running Programs</h3>
            <p>Use <code>Terminal.run</code>, as shown in the examples above, to run a <code>Program</code> and cause it to affect the terminal. This method is backend dependent. For example, on the Javascript backend it allows you to specify additional parameters that change how the terminal is rendered in the browser.</p>
            <div class="flex flex-row justify-between">
                <a class="pageNavigation" href="quick-start.html">←Quick Start</a> <a class="pageNavigation" href="examples.html">Examples→</a>
            </div>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
