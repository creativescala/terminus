<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 1.0.0" />
    <title>Terminus</title>
    
    
    <meta name="description" content="docs" />
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/creative-scala.css" /><link rel="stylesheet" type="text/css" href="xterm.css" />
    <script src="js/toc.js"></script><script src="js/solution.js"></script><script src="main.js"></script><script src="xterm.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar">
      <details>
        <summary>Terminus</summary>
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="examples.html">Examples</a></li>
          <li class="level1 nav-leaf"><a href="jvm.html">JVM Backend</a></li>
          <li class="level1 nav-leaf"><a href="js.html">Javascript Backend</a></li>
          <li class="level1 nav-leaf"><a href="native.html">Native Backend</a></li>
        </ul>
      </details>
    </nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 active nav-leaf"><a href="#">Terminus</a></li>
          <li class="level1 nav-leaf"><a href="examples.html">Examples</a></li>
          <li class="level1 nav-leaf"><a href="jvm.html">JVM Backend</a></li>
          <li class="level1 nav-leaf"><a href="js.html">Javascript Backend</a></li>
          <li class="level1 nav-leaf"><a href="native.html">Native Backend</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="terminus" class="title">Terminus</h1>
            <p>Terminus is a Scala 3 library for working with the terminal.
            It currently supports JVM, Scala Native, and Javascript backends.</p>
            
            <h2 id="setup" class="section">Setup</h2>
            <p>To use Terminus, add the following to your <code>build.sbt</code></p>
            <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.creativescala&quot;</span><span> %% </span><span class="string-literal">&quot;terminus-core&quot;</span><span> % </span><span class="string-literal">&quot;0.1&quot;</span></code></pre>
            
            <h2 id="usage" class="section">Usage</h2>
            <p>Import Terminus</p>
            <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">terminus</span><span>.*</span></code></pre>
            <p>Now you can call methods on the <code>Terminal</code> object. The core methods are <code>read</code> and <code>write</code>, but there are also methods to change color, move the cursor, erase content, and so on. On most terminals you will need to call <code>flush</code> or your output won&#39;t appear. Wrap a call to <code>run</code> around your entire program. Here&#39;s a small example that prints green text.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span> {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">display</span><span>.</span><span class="identifier">bold</span><span> {
    </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">foreground</span><span>.</span><span class="identifier">green</span><span> {
      </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;This is Terminus!&quot;</span><span>)
      </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
    }
  }
}</span></code></pre>
            <p>This produces the following output.</p>
            <div class="doodle" id="color-foreground-green"></div>
            <script>ColorForegroundGreen.go("color-foreground-green")</script>
            <p>See the <a href="examples.html">Examples</a> for more involved use cases.</p>
            
            <h2 id="design" class="section">Design</h2>
            <p>The API in the <code>terminus</code> package provides a functional API for working with the terminal.
            Methods consume and return context functions with type</p>
            <pre><code class="nohighlight"><span class="keyword">type</span><span> </span><span class="type-name">Program</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="type-name">Terminal</span><span> ?=&gt; </span><span class="type-name">A</span></code></pre>
            <p>where <code>Terminal</code> is a backend specific implementation that handles interfacing with the terminal. A <code>Program</code> represents a function that, when run, will do something with the terminal.</p>
            <p>Context functions are new to Scala 3, so many developers may not be familiar with how they work. There are three rules for working with them, described below.</p>
            <p>The first rule is that if the compiler can tell that a context function is expected it will automatically create one. We can do this with a <code>Program</code> type annotation. Here are some examples</p>
            <pre><code class="nohighlight"><span class="comment">// Most of the methods on Terminal return programs
</span><span class="keyword">val</span><span> </span><span class="identifier">aTerminalOperation</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some text&quot;</span><span>)

</span><span class="comment">// Any expression can be a Program with a type annotation
</span><span class="keyword">val</span><span> </span><span class="identifier">aProgram</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span></code></pre>
            <p>The second rule is that context functions will be automatically applied if there is a <code>given</code> value of the appropriate type in scope. This is what allows us to write effectful code in so-called <em>direct-style</em>, which just means writing normal code without monads or other complications. Here&#39;s an example that mixes effectful code, using the terminal, with some normal code. Notice that the entire result is a <code>Program</code>. This type annotation means the compiler constructs a context function around the entire block.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">writeSomeStuff</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
  </span><span class="comment">// We can mix normal code in
</span><span>  </span><span class="keyword">val</span><span> </span><span class="identifier">result</span><span> = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;More output&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
  </span><span class="identifier">result</span><span>
}</span></code></pre>
            <p>We can do the same thing with a method, by specifying the return type is a <code>Program</code>. Here&#39;s an example.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">doSomeStuff</span><span>(): </span><span class="type-name">Program</span><span>[</span><span class="type-name">Int</span><span>] = {
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">result</span><span> = </span><span class="number-literal">1</span><span> + </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;More output&quot;</span><span>)
  </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">flush</span><span>()
  </span><span class="identifier">result</span><span>
}</span></code></pre>
            <p>The final rule is if we don&#39;t tell the compiler we&#39;re expecting a context function, we may get an error when the compiler attempts to apply a context function to a given value that does not exist.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)
</span><span class="comment">// error: 
// No given instance of type terminus.effect.Writer was found for parameter of (terminus.effect.Writer) ?=&gt; Unit</span></code></pre>
            <p>We can solve this by either adding a context function type annotation</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ok</span><span>: </span><span class="type-name">Program</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>)</span></code></pre>
            <p>or by providing a <code>given</code> value of the required type, which is what <code>Terminal.run</code> does.</p>
            <pre><code class="nohighlight"><span class="type-name">Terminal</span><span>.</span><span class="identifier">run</span><span>(</span><span class="type-name">Terminal</span><span>.</span><span class="identifier">write</span><span>(</span><span class="string-literal">&quot;Some output&quot;</span><span>))</span></code></pre>
            <p>If you want to work directly with the terminal, without working with context functions, you can work with the types in <code>terminus.effect</code>.</p>
            
            <h2 id="low-level-code" class="section">Low-level Code</h2>
            <p>All the ANSI escape codes used by Terminus are defined in <code>terminus.effect.AnsiCodes</code>.
            This can be useful if you want to write <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">escape codes</a> directly to the terminal without the abstractions provided by the Terminus DSL.
            Here&#39;s a simple example.</p>
            <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">terminus</span><span>.</span><span class="identifier">effect</span><span>.</span><span class="type-name">AnsiCodes</span><span>

</span><span class="type-name">AnsiCodes</span><span>.</span><span class="identifier">foreground</span><span>.</span><span class="identifier">red</span><span>
</span><span class="comment">// res6: String = &quot;\u001b[31m&quot;
</span><span class="type-name">AnsiCodes</span><span>.</span><span class="identifier">erase</span><span>.</span><span class="identifier">line</span><span>
</span><span class="comment">// res7: String = &quot;\u001b[2K&quot;</span></code></pre>
            
            <h2 id="notes" class="section">Notes</h2>
            <p>You won&#39;t be able to run terminal programs from sbt if the JVM forks when running. That is, if you have the setting</p>
            <pre><code class="nohighlight"><span class="identifier">run</span><span> / </span><span class="identifier">fork</span><span> := </span><span class="boolean-literal">true</span></code></pre>
            <p>the forked JVM won&#39;t have access to a terminal and therefore any terminal programs will not work as expected.</p>
            
            <h2 id="related-work" class="section">Related Work</h2>
            <p><a href="https://github.com/com-lihaoyi/fansi">Fansi</a> may be a better choice if your only interest in styling output printed to a terminal.</p>
            <p><a href="https://github.com/neandertech/cue4s/">Cue4s</a> provides higher level abstractions for building UIs in the terminal.</p>
            
            <h2 id="further-reading" class="section">Further Reading</h2>
            <p>The terminal is much more evolved than designed. I haven&#39;t been able to find a single document that describes all the features. Here are a few resources that I&#39;ve found useful for piecing together how things should work:</p>
            <ul>
              <li>
                <p>Wikipedia has reasonable documentation of the <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>, though it doesn&#39;t cover semantics in detail (e.g. erasing seems to move the cursor but Wikipedia doesn&#39;t describe this in all cases.)</p>
              </li>
              <li>
                <p><a href="http://web.archive.org/web/20160407191115/http://homes.mpimf-heidelberg.mpg.de/~rohm/computing/mpimf/notes/terminal.html">This article</a> describes a bit about cursor and application mode.</p>
              </li>
              <li>
                <p><a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/">The Kitty Keyboard Protocol</a> describes the goofiness in the basic terminal key handling and also describes a fix.</p>
              </li>
              <li>
                <p><a href="https://vt100.net/emu/dec_ansi_parser">A state machine for parsing terminal input</a> will also be handy.</p>
              </li>
            </ul>
            <div class="flex flex-row justify-between">
                 <a class="pageNavigation" href="examples.html">Examples→</a>
            </div>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
